"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = setupJasmine;

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

/**
 * Flag, showing that Polly is active
 */
const IS_POLLY_ACTIVE = Symbol('IS_POLLY_ACTIVE');
/**
 * Flag, showing that proxy test methods are attached
 */

const IS_POLLY_ATTACHED = Symbol('IS_POLLY_ATTACHED');
/**
 * Shared context to keep polly instance and
 * options for a specific run
 */

const pollyContext = {
  polly: null,
  options: {}
};
/**
 * Get full spec description, starting from the top
 * suite
 *
 * @param {Object} spec Current spec
 * @param {Object} suite Current spec parent suite
 *
 * @returns {string} Full spec description (e.g. "suite/should do something")
 */

function getRecordingName(spec, suite) {
  const descriptions = [spec.description];

  while (suite) {
    suite.description && descriptions.push(suite.description);
    suite = suite.parentSuite;
  }

  return descriptions.reverse().join('/');
}
/**
 * Recursively go through suite and its children
 * and return the first that matches the findFn
 * condition
 *
 * @param {Object} suite Starting point
 * @param {Function} findFn Find function
 *
 * @returns {?Object} Matching suite or null
 */


function findSuiteRec(suite, findFn) {
  if (findFn(suite)) return suite;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (suite.children || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      const child = _step.value;
      const result = findSuiteRec(child, findFn);

      if (result !== null) {
        return result;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return null;
}
/**
 * Create proxy for jasmine test function that starts and
 * stops Polly on before/after hooks
 *
 * @param {Object} Polly Polly constructor
 * @param {Function} fn Original test runner test function
 * @param {Object} jasmineEnv Jasmine environment
 *
 * @returns {Function} Proxy function
 */


function createTestFnProxy(Polly, fn, jasmineEnv) {
  return function testFn() {
    const spec = fn.apply(jasmineEnv, arguments);
    const specHooks = spec.beforeAndAfterFns;

    spec.beforeAndAfterFns = function beforeAndAfterFns() {
      const _specHooks$apply = specHooks.apply(spec, arguments),
            befores = _specHooks$apply.befores,
            afters = _specHooks$apply.afters;

      const before =
      /*#__PURE__*/
      function () {
        var _before = _asyncToGenerator(function* (done) {
          if (jasmineEnv[IS_POLLY_ACTIVE]) {
            const topSuite = jasmineEnv.topSuite();
            const specParentSuite = findSuiteRec(topSuite, suite => (suite.children || []).some(child => child.id === spec.id));
            let recordingName = getRecordingName(spec, specParentSuite); // In jest top suite description is empty, in jasmine it is
            // randomly generated string. We don't want it to be used
            // as recording name if it exists

            if (topSuite.description) {
              recordingName = recordingName.replace(`${topSuite.description}/`, '');
            }

            pollyContext.polly = new Polly(recordingName, pollyContext.options);
          }

          done && done();
        });

        return function before(_x) {
          return _before.apply(this, arguments);
        };
      }();

      const after =
      /*#__PURE__*/
      function () {
        var _after = _asyncToGenerator(function* (done) {
          if (jasmineEnv[IS_POLLY_ACTIVE]) {
            yield pollyContext.polly.stop();
            pollyContext.polly = null;
          }

          done && done();
        });

        return function after(_x2) {
          return _after.apply(this, arguments);
        };
      }();

      return {
        befores: [{
          fn: before
        }, ...befores],
        afters: [...afters, {
          fn: after
        }]
      };
    };

    return spec;
  };
}
/**
 * Attach test fn proxies to jasmine environment if needed and
 * add beforeAll/afterAll hooks that will activate/deactivate
 * Polly when running test suite
 *
 * @param {Object} Polly Polly constructor
 * @param {Object} defaults Polly default options
 * @param {Object} ctx Global context
 *
 * @returns {Object} Context with `polly` property
 */


function setupJasmine(Polly, defaults = {}, ctx = global) {
  if (!ctx.jasmine || ctx.jasmine && typeof ctx.jasmine.getEnv !== 'function') {
    throw new TypeError('Couldn\'t find jasmine environment. Make sure that you are using "setupJasmine" in ' + 'jasmine/jest environment or that you provided proper jasmine environment when calling "setupJasmine"');
  }

  const jasmineEnv = ctx.jasmine.getEnv();

  if (!jasmineEnv[IS_POLLY_ATTACHED]) {
    jasmineEnv.it = createTestFnProxy(Polly, jasmineEnv.it, jasmineEnv);
    jasmineEnv.fit = createTestFnProxy(Polly, jasmineEnv.fit, jasmineEnv);
    jasmineEnv[IS_POLLY_ATTACHED] = true;
    jasmineEnv[IS_POLLY_ACTIVE] = false;
  }

  ctx.beforeAll(() => {
    pollyContext.options = defaults;
    jasmineEnv[IS_POLLY_ACTIVE] = true;
  });
  ctx.afterAll(() => {
    pollyContext.options = null;
    jasmineEnv[IS_POLLY_ACTIVE] = false;
  });
  return {
    get polly() {
      return pollyContext.polly;
    }

  };
}

setupJasmine.IS_POLLY_ACTIVE = IS_POLLY_ACTIVE;
setupJasmine.IS_POLLY_ATTACHED = IS_POLLY_ATTACHED;